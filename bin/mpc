#!/usr/bin/env ruby

require_relative '../lib/mpc/mpc'
require_relative '../lib/slang'

include MPC

class SmallC < Language
  define :ident, "/[a-zA-Z_][a-zA-Z0-9_]*/"
  define :number, "/[0-9]+/"
  define :character, "/'.'/"
  define :string, "/\"(\\\\.|[^\"])*\"/"
  define :factor, "'(' <lexp> ')'
          | <number>
          | <character>
          | <string>
          | <ident> '(' <lexp>? (',' <lexp>)* ')'
          | <ident> "
  define :term, "<factor> (('*' | '/' | '%') <factor>)*"
  define :lexp, "<term> (('+' | '-') <term>)*"
  define :stmt, "'{' <stmt>* '}'
          | \"while\" '(' <exp> ')' <stmt>
          | \"if\"    '(' <exp> ')' <stmt>
          | <ident> '=' <lexp> ';'
          | \"print\" '(' <lexp>? ')' ';'
          | \"return\" <lexp>? ';'
          | <ident> '(' <ident>? (',' <ident>)* ')' ';'"
  define :exp, "<lexp> '>' <lexp>
          | <lexp> '<' <lexp>
          | <lexp> \">=\" <lexp>
          | <lexp> \"<=\" <lexp>
          | <lexp> \"!=\" <lexp>
          | <lexp> \"==\" <lexp>"
  define :typeident, "(\"int\" | \"char\") <ident>"
  define :decls, "(<typeident> ';')*"
  define :args, "<typeident>? (',' <typeident>)*"
  define :body, "'{' <decls> <stmt>* '}'"
  define :procedure, "(\"int\" | \"char\") <ident> '(' <args> ')' <body>"
  define :main, "\"main\" '(' ')' <body>"
  define :includes, "(\"#include\" <string>)*"
  define :smallc, "/^/ <includes> <decls> <procedure>* <main> /$/"
end

#ast = AST.new SmallC.new.parse_file('fib.smallc', :smallc)
#ast.display

module MPC
  class AST
    def parse_contents(exp)
      case tag
      when :char
        exp << contents.to_sym unless contents == '(' || contents == ')'
      when :term, :lexp
        children[0].parse_contents(exp) if children.size == 1
        call = []
        children[1].parse_contents(call)
        children[0].parse_contents(call)
        args = []
        children[2].parse_contents(args)
        call << args

        obj = call
        children[3..-1].each_slice(2) do |child|
          call = []
          child[0].parse_contents(call)
          call << obj
          args = []
          child[1].parse_contents(args)
          call << args
          obj = call
        end
        exp << call
      when :integer
        exp << contents.to_i
      when :float
        exp << contents.to_f
      else
        children.each do |child|
          child.parse_contents exp
        end
      end
    end
  end
end

module SLang
  class MyLanguage < Language
    define :space, "/[ \t]/"
    define :blank, "<space>+"
    define :newline, "/\\n/"
    define :ident, "/[a-zA-Z_][a-zA-Z0-9_]*/"
    define :integer, "/[1-9][0-9]*/"
    define :float, "/[0-9]+\\.[0-9]+/"
    define :number, "<float> | <integer>"
    define :factor, "<blank>* ('(' <lexp> ')'
            | <number>
            | <ident> '(' <lexp>? (',' <lexp>)* ')'
            | <ident> ) <blank>*"
    define :term, "<factor> (('*' | '/' | '%') <factor>)*"
    define :lexp, "<term> (('+' | '-') <term>)*"
    define :main, "/^/ <lexp>* /$/"
  end

  code = '1 +2* 3.5- 7 * (1.2 + 2.25)'

  ast = AST.new MyLanguage.new(:whitespace_sensitive).parse_string(code, :main)
  exp = [:ret]
  ast.parse_contents(exp)
  p exp
  puts Program.new.run(exp)
end


